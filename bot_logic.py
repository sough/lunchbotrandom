# bot_logic.py
import logging
import os
import random
import requests
import json
import traceback
import math
import urllib.parse
from telegram import Update, InlineKeyboardButton, InlineKeyboardMarkup
from telegram.ext import (
    Application, CommandHandler, MessageHandler, filters,
    CallbackContext, CallbackQueryHandler, ConversationHandler
)

logging.basicConfig(level=logging.ERROR, format='%(asctime)s - %(name)s - %(levelname)s - %(message)s')
logger = logging.getLogger(__name__)
DEFAULT_RADIUS_KM = 1.0
ASKING_RADIUS = 1

def escape_markdown_v2(text: str) -> str:
    escape_chars = r'_*[]()~`>#+-=|{}.!'; return text.translate(str.maketrans({char: f'\\{char}' for char in escape_chars}))

async def get_coordinates(address: str) -> tuple | None:
    url = "https://catalog.api.2gis.com/3.0/items/geocode"; params = {"q": address, "key": os.getenv("DGIS_API_KEY"), "fields": "items.point"}
    try:
        response = requests.get(url, params=params); response.raise_for_status(); data = response.json()
        if data.get("meta", {}).get("code") == 200 and data.get("result", {}).get("items"):
            point = data["result"]["items"][0]["point"]; return point['lat'], point['lon']
        else: logger.warning(f"2GIS API –Ω–µ –Ω–∞—à–µ–ª –∫–æ–æ—Ä–¥–∏–Ω–∞—Ç –¥–ª—è –∞–¥—Ä–µ—Å–∞ '{address}'."); return None
    except requests.RequestException as e: logger.error(f"–û—à–∏–±–∫–∞ —Å–µ—Ç–∏ –ø—Ä–∏ –∑–∞–ø—Ä–æ—Å–µ –∫ 2GIS Geocode API: {e}"); return None

def get_straight_line_distance(start_coords: tuple, end_coords: tuple) -> int:
    R = 6371e3
    lat1, lon1 = start_coords; lat2, lon2 = end_coords
    phi1 = math.radians(lat1); phi2 = math.radians(lat2)
    delta_phi = math.radians(lat2 - lat1); delta_lambda = math.radians(lon2 - lon1)
    a = math.sin(delta_phi / 2) * math.sin(delta_phi / 2) + math.cos(phi1) * math.cos(phi2) * math.sin(delta_lambda / 2) * math.sin(delta_lambda / 2)
    c = 2 * math.atan2(math.sqrt(a), math.sqrt(1 - a))
    distance = R * c
    return int(distance)

async def get_random_lunch_place(lat: float, lon: float, radius_meters: int) -> dict | None:
    all_places = []
    for page_num in range(1, 11):
        params = {'key': os.getenv("DGIS_API_KEY"), 'q': '–ø–æ–µ—Å—Ç—å', 'point': f'{lon},{lat}', 'radius': radius_meters, 'type': 'branch', 'fields': 'items.name,items.address_name,items.url,items.point_info', 'page_size': 10, 'page': page_num}
        url = "https://catalog.api.2gis.com/3.0/items"
        try:
            response = requests.get(url, params=params); response.raise_for_status(); data = response.json()
            if data.get("meta", {}).get("code") == 200 and data.get("result", {}).get("items"): all_places.extend(data["result"]["items"])
            else: break
        except requests.RequestException: break
    
    if all_places:
        found_places_names = [place.get('name', 'N/A') for place in all_places]
        logger.info(f"Found {len(found_places_names)} places: {found_places_names}")
        place_choice = random.choice(all_places)
        point_info = place_choice.get('point_info', {}); point_coords = point_info.get('point', {})
        return {
            "name": place_choice.get("name", "N/A"), 
            "address": place_choice.get("address_name", ""), # Return empty string if no address
            "url": place_choice.get("url", ""),
            "lat": point_coords.get('lat'), "lon": point_coords.get('lon')
        }
    return None

def create_result_keyboard() -> InlineKeyboardMarkup:
    keyboard = [[InlineKeyboardButton("–ü–æ–≤—Ç–æ—Ä–∏—Ç—å –ø–æ–∏—Å–∫ üîÅ", callback_data="repeat_search"), InlineKeyboardButton("–°–º–µ–Ω–∏—Ç—å —Ä–∞–¥–∏—É—Å üìè", callback_data="change_radius")]]; return InlineKeyboardMarkup(keyboard)

async def perform_search_and_reply(update: Update, context: CallbackContext, coords: tuple, is_new_search: bool = False):
    """–í—ã–ø–æ–ª–Ω—è–µ—Ç –ø–æ–∏—Å–∫ –∏ –æ—Ç–ø—Ä–∞–≤–ª—è–µ—Ç —Ä–µ–∑—É–ª—å—Ç–∞—Ç, –ø—Ä–æ–≤–µ—Ä—è—è –Ω–∞–ª–∏—á–∏–µ –∞–¥—Ä–µ—Å–∞."""
    if update.callback_query:
        await update.callback_query.edit_message_text(text="_–ò—â—É –¥—Ä—É–≥–æ–π –≤–∞—Ä–∏–∞–Ω—Ç\\.\\.\\._", parse_mode='MarkdownV2')
    
    radius_km = context.user_data.get('radius_km', DEFAULT_RADIUS_KM)
    radius_meters = int(radius_km * 1000)
    place = await get_random_lunch_place(coords[0], coords[1], radius_meters)
    
    if not place:
        message_text = f"–ö —Å–æ–∂–∞–ª–µ–Ω–∏—é, —è –Ω–µ –Ω–∞—à–µ–ª –∑–∞–≤–µ–¥–µ–Ω–∏–π –≤ —Ä–∞–¥–∏—É—Å–µ {radius_km} –∫–º."
        if update.callback_query: await update.callback_query.edit_message_text(text=message_text)
        elif update.message: await update.message.reply_text(text=message_text)
        return
        
    title = "üéâ *–í—ã–±–æ—Ä —Å–¥–µ–ª–∞–Ω\\!* üéâ" if is_new_search else "üéâ *–ù–æ–≤—ã–π –≤–∞—Ä–∏–∞–Ω—Ç\\!* üéâ"
    name = escape_markdown_v2(place.get('name', ''))
    address = escape_markdown_v2(place.get('address', '')) # Get address from place dict

    # –ù–∞—á–∏–Ω–∞–µ–º —Ñ–æ—Ä–º–∏—Ä–æ–≤–∞—Ç—å —Å–æ–æ–±—â–µ–Ω–∏–µ
    message_text = f"{title}\n\nüìç *–ù–∞–∑–≤–∞–Ω–∏–µ:* {name}\n"

    # –î–æ–±–∞–≤–ª—è–µ–º —Å—Ç—Ä–æ–∫—É —Å –∞–¥—Ä–µ—Å–æ–º, —Ç–æ–ª—å–∫–æ –µ—Å–ª–∏ –æ–Ω –Ω–µ –ø—É—Å—Ç–æ–π
    if address:
        message_text += f"üè† *–ê–¥—Ä–µ—Å:* {address}\n"
    
    place_coords = (place.get('lat'), place.get('lon'))
    if all(place_coords):
        distance_m = get_straight_line_distance(start_coords=coords, end_coords=place_coords)
        message_text += f"üìè *–†–∞—Å—Å—Ç–æ—è–Ω–∏–µ:* –ø—Ä–∏–º–µ—Ä–Ω–æ {distance_m} –º –ø–æ –ø—Ä—è–º–æ–π\n"

    place_url = place.get('url')
    if place_url:
        url_to_send = place_url
    else:
        place_name_encoded = urllib.parse.quote_plus(place.get('name', ''))
        city_name = context.user_data.get('city', 'almaty').lower()
        url_to_send = f"https://2gis.kz/{city_name}/search/{place_name_encoded}"

    message_text += f"\n[–ü–æ—Å–º–æ—Ç—Ä–µ—Ç—å –Ω–∞ –∫–∞—Ä—Ç–µ 2GIS]({url_to_send})"
    
    reply_markup = create_result_keyboard()
    if update.callback_query: await update.callback_query.edit_message_text(text=message_text, parse_mode='MarkdownV2', reply_markup=reply_markup)
    elif update.message: await update.message.reply_markdown_v2(message_text, reply_markup=reply_markup)

async def error_handler(update: object, context: CallbackContext) -> None:
    logger.error("–ü—Ä–æ–∏–∑–æ—à–ª–æ –∏—Å–∫–ª—é—á–µ–Ω–∏–µ –ø—Ä–∏ –æ–±—Ä–∞–±–æ—Ç–∫–µ –æ–±–Ω–æ–≤–ª–µ–Ω–∏—è:", exc_info=context.error); tb_list = traceback.format_exception(None, context.error, context.error.__traceback__); tb_string = "".join(tb_list)
    update_dict = update.to_dict() if isinstance(update, Update) else str(update); update_str = json.dumps(update_dict, indent=2, ensure_ascii=False)
    message = (f"--- –ù–∞—á–∞–ª–æ –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏–∏ –æ–± –æ—à–∏–±–∫–µ ---\nUpdate: {update_str}\n\nUser Data: {context.user_data}\n\nTraceback:\n{tb_string}--- –ö–æ–Ω–µ—Ü –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏–∏ –æ–± –æ—à–∏–±–∫–µ ---"); logger.error(message)

async def start(update: Update, context: CallbackContext) -> None:
    user = update.effective_user; current_radius = context.user_data.get('radius_km', DEFAULT_RADIUS_KM)
    start_message = (f"–ü—Ä–∏–≤–µ—Ç, {user.mention_html()}!\n\n–Ø –ø–æ–º–æ–≥—É —Ç–µ–±–µ –≤—ã–±—Ä–∞—Ç—å, –≥–¥–µ –ø–æ–æ–±–µ–¥–∞—Ç—å.\n"
                     f"–¢–µ–∫—É—â–∏–π —Ä–∞–¥–∏—É—Å –ø–æ–∏—Å–∫–∞: <b>{current_radius} –∫–º</b>. –ß—Ç–æ–±—ã –µ–≥–æ –∏–∑–º–µ–Ω–∏—Ç—å, –∏—Å–ø–æ–ª—å–∑—É–π –∫–æ–º–∞–Ω–¥—É /radius.\n\n"
                     "–î–ª—è –Ω–∞—á–∞–ª–∞, –ø–æ–∂–∞–ª—É–π—Å—Ç–∞, –Ω–∞–ø–∏—à–∏ –º–Ω–µ —Å–≤–æ–π –≥–æ—Ä–æ–¥.")
    await update.message.reply_html(start_message)

async def set_city(update: Update, context: CallbackContext) -> None:
    context.user_data.pop('city', None); context.user_data.pop('last_coords', None)
    await update.message.reply_text("–•–æ—Ä–æ—à–æ, –¥–∞–≤–∞–π—Ç–µ —Å–º–µ–Ω–∏–º –≥–æ—Ä–æ–¥. –ö–∞–∫–æ–π —Ç–µ–ø–µ—Ä—å –≤—ã–±–µ—Ä–µ–º?")

async def handle_message(update: Update, context: CallbackContext) -> None:
    user_text = update.message.text
    if 'city' not in context.user_data:
        coords = await get_coordinates(user_text)
        if not coords: await update.message.reply_text("–ù–µ —Å–º–æ–≥ –Ω–∞–π—Ç–∏ —Ç–∞–∫–æ–π –≥–æ—Ä–æ–¥. –ü–æ–ø—Ä–æ–±—É–π—Ç–µ –µ—â–µ —Ä–∞–∑."); return
        context.user_data['city'] = user_text
        escaped_city = escape_markdown_v2(user_text)
        await update.message.reply_markdown_v2(f"–û—Ç–ª–∏—á–Ω–æ\\! –í–∞—à –≥–æ—Ä–æ–¥ '{escaped_city}' —Å–æ—Ö—Ä–∞–Ω–µ–Ω\\.\n–¢–µ–ø–µ—Ä—å –æ—Ç–ø—Ä–∞–≤—å—Ç–µ –º–Ω–µ —É–ª–∏—Ü—É –∏ –Ω–æ–º–µ—Ä –¥–æ–º–∞ \\(–Ω–∞–ø—Ä–∏–º–µ—Ä, '–ê–±–∞—è 15'\\)\\.")
        return
    city = context.user_data['city']; full_address = f"{city}, {user_text}"
    escaped_full_address = escape_markdown_v2(full_address)
    await update.message.reply_markdown_v2(f"–ò—â—É –∑–∞–≤–µ–¥–µ–Ω–∏—è —Ä—è–¥–æ–º —Å –∞–¥—Ä–µ—Å–æ–º: *{escaped_full_address}*\\.\\.\\.\n_\\(–≠—Ç–æ –º–æ–∂–µ—Ç –∑–∞–Ω—è—Ç—å –Ω–µ—Å–∫–æ–ª—å–∫–æ —Å–µ–∫—É–Ω–¥\\)_")
    coords = await get_coordinates(full_address)
    if not coords: await update.message.reply_text("–ù–µ —Å–º–æ–≥ –Ω–∞–π—Ç–∏ —Ç–∞–∫–æ–π –∞–¥—Ä–µ—Å."); return
    context.user_data['last_coords'] = coords
    await perform_search_and_reply(update, context, coords, is_new_search=True)

async def button_handler(update: Update, context: CallbackContext) -> int:
    query = update.callback_query; await query.answer()
    if query.data == "repeat_search":
        coords = context.user_data.get('last_coords')
        if not coords: await query.edit_message_text(text="–ß—Ç–æ-—Ç–æ –ø–æ—à–ª–æ –Ω–µ —Ç–∞–∫."); return
        await perform_search_and_reply(update, context, coords)
        return
    elif query.data == "change_radius":
        current_radius = context.user_data.get('radius_km', DEFAULT_RADIUS_KM)
        await query.message.reply_text(f"–¢–µ–∫—É—â–∏–π —Ä–∞–¥–∏—É—Å –ø–æ–∏—Å–∫–∞: {current_radius} –∫–º.\n–û—Ç–ø—Ä–∞–≤—å—Ç–µ –Ω–æ–≤–æ–µ –∑–Ω–∞—á–µ–Ω–∏–µ –≤ –∫–∏–ª–æ–º–µ—Ç—Ä–∞—Ö (–Ω–∞–ø—Ä–∏–º–µ—Ä, 0.5 –∏–ª–∏ 3).\n\n–ß—Ç–æ–±—ã –æ—Ç–º–µ–Ω–∏—Ç—å, –≤–≤–µ–¥–∏—Ç–µ /cancel.")
        return ASKING_RADIUS

async def radius_start(update: Update, context: CallbackContext) -> int:
    current_radius = context.user_data.get('radius_km', DEFAULT_RADIUS_KM); await update.message.reply_text(f"–¢–µ–∫—É—â–∏–π —Ä–∞–¥–∏—É—Å –ø–æ–∏—Å–∫–∞: {current_radius} –∫–º.\n–û—Ç–ø—Ä–∞–≤—å—Ç–µ –Ω–æ–≤–æ–µ –∑–Ω–∞—á–µ–Ω–∏–µ –≤ –∫–∏–ª–æ–º–µ—Ç—Ä–∞—Ö (–Ω–∞–ø—Ä–∏–º–µ—Ä, 0.5 –∏–ª–∏ 3).\n\n–ß—Ç–æ–±—ã –æ—Ç–º–µ–Ω–∏—Ç—å, –≤–≤–µ–¥–∏—Ç–µ /cancel."); return ASKING_RADIUS

async def radius_receive(update: Update, context: CallbackContext) -> int:
    user_text = update.message.text.replace(',', '.');
    try:
        new_radius = float(user_text)
        if not (0.1 <= new_radius <= 10): raise ValueError("–†–∞–¥–∏—É—Å –≤–Ω–µ –¥–æ–ø—É—Å—Ç–∏–º–æ–≥–æ –¥–∏–∞–ø–∞–∑–æ–Ω–∞.")
        context.user_data['radius_km'] = new_radius
        coords = context.user_data.get('last_coords')
        if coords:
            await update.message.reply_text(f"–†–∞–¥–∏—É—Å –æ–±–Ω–æ–≤–ª–µ–Ω: {new_radius} –∫–º. –ó–∞–ø—É—Å–∫–∞—é –ø–æ–≤—Ç–æ—Ä–Ω—ã–π –ø–æ–∏—Å–∫...")
            await perform_search_and_reply(update, context, coords, is_new_search=True)
        else:
            await update.message.reply_text(f"–û—Ç–ª–∏—á–Ω–æ! –ù–æ–≤—ã–π —Ä–∞–¥–∏—É—Å –ø–æ–∏—Å–∫–∞ —Å–æ—Ö—Ä–∞–Ω–µ–Ω: {new_radius} –∫–º.")
    except ValueError:
        await update.message.reply_text("–≠—Ç–æ –Ω–µ –ø–æ—Ö–æ–∂–µ –Ω–∞ —á–∏—Å–ª–æ. –ü–æ–∂–∞–ª—É–π—Å—Ç–∞, –≤–≤–µ–¥–∏—Ç–µ –∫–æ—Ä—Ä–µ–∫—Ç–Ω–æ–µ –∑–Ω–∞—á–µ–Ω–∏–µ (–æ—Ç 0.1 –¥–æ 10)."); return ASKING_RADIUS
    return ConversationHandler.END

async def cancel(update: Update, context: CallbackContext) -> int:
    await update.message.reply_text("–î–µ–π—Å—Ç–≤–∏–µ –æ—Ç–º–µ–Ω–µ–Ω–æ."); return ConversationHandler.END

def add_handlers(application: Application):
    conv_handler = ConversationHandler(
        entry_points=[CommandHandler('radius', radius_start)],
        states={ASKING_RADIUS: [MessageHandler(filters.TEXT & ~filters.COMMAND, radius_receive)]},
        fallbacks=[CommandHandler('cancel', cancel)],
        per_message=False, persistent=True, name="radius_conversation"
    )
    application.add_handler(conv_handler)
    application.add_handler(CommandHandler("start", start))
    application.add_handler(CommandHandler("setcity", set_city))
    application.add_handler(CallbackQueryHandler(button_handler))
    application.add_handler(MessageHandler(filters.TEXT & ~filters.COMMAND, handle_message))
    application.add_error_handler(error_handler)